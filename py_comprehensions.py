"""推导式"""
"""推导和规约
语法分析器在构建一棵语法分析树时，常用的方法可以分为自顶向下和自底向上的。顾名思义，自顶向下的方法是从语法分析树的根结点开始向
叶子结点构造的方法，自底向上的方法是从语法分析树的叶子结点开始向根结点构造的方法。在自顶向下的构造过程中，需要从一个非叶子结点
“推导”出其子树；在自底向上的构造中，需要把几个非根结点“规约”成其根结点。

推导产生终止符串。
规约是推导的逆过程。
"""
"""
列表推导式
    [<表达式> for <变量> in <可迭代对象> if <逻辑条件>]
字典推导式
    {<键值表达式>:<元素表达式> for <变量> in <可迭代对象> if <逻辑条件>}
集合推导式
    {<元素表达式> for <变量> in <可迭代对象> if <逻辑条件>}
"""
out = [x * x for x in range(10)]
out = {'K%d' % (x,): x ** 3 for x in range(10)}  # 元素为乘方
# out = {x * 3 for x in range(10)}
out = [x + y for x in range(10) for y in range(10)]
out = [x.upper() for x in [1, 'abc', 'xyz', True] if isinstance(x, str)]  # 加上推导条件
print(out)

"""
生成器推导式
(<元素表达式> for <变量> in <可迭代对象> if <逻辑条件>)
返回一个生成器对象，也是可迭代对象（可用于循环迭代）
生成器并不立即产生全部元素，仅在要用到元素时才生成，可以极大节省内存
"""
out = (x * x for x in range(10))
print(out)
for n in out:  # 遍历推导
    print(n)

"""生成器函数
根据条件生成对象，使用yield返回 yield返回不会造成函数退出，直到条件不满足跳过yield
从cpu的角度说，虽然推导式生成终止符串，但是并不会造成函数退出，这是动态解释型语言才有的特性，因为编译过程确定了指令（我猜的！）
"""


def gen_even_number(num):
    n = 0
    while n < num:
        yield n
        n += 2


for i in gen_even_number(10):
    print(i)
